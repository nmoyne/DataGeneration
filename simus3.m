function [RF,param,RFspectrum] = simus3(varargin)

%SIMUS3   Simulation of ultrasound RF signals for a a planar 2-D array
%   RF = SIMUS3(X,Y,Z,RC,DELAYS,PARAM) simulates ultrasound RF radio-
%   frequency signals generated by an ultrasound planar 2-D array
%   insonifying a medium of scatterers.
%   The scatterers are characterized by their coordinates (X,Y,Z) and
%   reflection coefficients RC.
%
%   Use SIMUS for uniform linear or convex arrays. 
%
%   X, Y, Z and RC must be of same size. The elements of the 2-D array are
%   excited at different time delays, given by the vector DELAYS. The
%   transmission and reception characteristics must be given in the
%   structure PARAM (see below for details).
%
%   >--- Try it: enter "simus3" in the command window for an example ---< 
%
%   The RF output matrix contains Number_of_Elements columns. Each column
%   therefore represents an RF signal. The number of rows depends on the
%   depth and the sampling frequency PARAM.fs (see below). By default, the
%   sampling frequency is four times the center frequency.
%
%   Units: X,Y,Z must be in m; DELAYS must be in s; RC has no unit.
%
%   DELAYS can be a matrix. This syntax can be used to simulate MPT
%   (multi-plane transmit) sequences. In this case, each ROW represents a
%   delay series. For example, to create a 4-MPT sequence with a
%   1024-element matrix array, the DELAYS matrix must have 4 rows and 1024
%   columns (size = [4 1024]).
%   Note: Use TXDELAY3 to create standard delays (focus point, focus line,
%         plane waves, diverging waves) with a matrix array.
%
%   SIMUS3 uses PFIELD3 during transmission and reception. The parameters
%   that must be included in the structure PARAM are similar as those in
%   PFIELD3. Additional parameters are also required (see below).
%
%   ---
%   NOTE #1: X-, Y-, and Z-axes
%   Conventional axes are used:
%   The X-axis is PARALLEL to the transducer and points from the first
%   (leftmost) element to the last (rightmost) element (X = 0 at the CENTER
%   of the transducer). The Z-axis is PERPENDICULAR to the transducer and
%   points downward (Z = 0 at the level of the transducer, Z increases as
%   depth increases). The Y-axis is such that the coordinates are
%   right-handed.
%   ---
%   NOTE #2: Simplified method: Directivity
%   By default, the calculation is made faster by assuming that the
%   directivity of the elements is dependent only on the central frequency.
%   This simplification very little affects the pressure field in most
%   situations (except near the array). To turn off this option, use
%   OPTIONS.FullFrequencyDirectivity = true.
%   (see ADVANCED OPTIONS below).
%   ---
%
%   PARAM is a structure that contains the following fields:
%   -------------------------------------------------------
%       *** TRANSDUCER PROPERTIES ***
%   1)  PARAM.fc: central frequency (in Hz, REQUIRED)
%   2)  PARAM.elements: x- and y-coordinates of the element centers
%            (in m, REQUIRED). It MUST be a two-row matrix, with the 1st
%            and 2nd rows containing the x and y coordinates, respectively. 
%   3)  PARAM.width: element width, in the x-direction (in m, REQUIRED)
%   4)  PARAM.height: element height, in the y-direction (in m, REQUIRED)
%   5)  PARAM.bandwidth: pulse-echo 6dB fractional bandwidth (in %)
%            The default is 75%.
%   6)  PARAM.baffle: property of the baffle:
%            'soft' (default), 'rigid', or a scalar > 0.
%            See "Note on BAFFLE properties" below for details
%
%       *** MEDIUM PARAMETERS ***
%   7)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
%   8)  PARAM.attenuation: attenuation coefficient (dB/cm/MHz, default: 0)
%            Notes: A linear frequency-dependence is assumed.
%                   A typical value for soft tissues is ~0.5 dB/cm/MHz.
%
%       *** TRANSMIT PARAMETERS ***
%   9)  PARAM.TXapodization: transmit apodization (default: no apodization)
%   10) PARAM.TXnow: number of wavelengths of the TX pulse (default: 1)
%   11) PARAM.TXfreqsweep: frequency sweep for a linear chirp (default: [])
%                          To be used to simulate a linear TX down-chirp.
%
%       *** RECEIVE PARAMETERS *** (not in PFIELD3)
%   14) PARAM.fs: sampling frequency (in Hz, default = 4*param.fc)
%   15) PARAM.RXdelay: reception law delays (in s, default = 0)
%
%   Other syntaxes:
%   --------------
%   i}  [RF,PARAM] = SIMUS3(...) updates the fields of the PARAM structure.
%   ii} [...] = SIMUS3 without any input argument provides an example
%        designed to produce RF signals from a focused ultrasound beam
%        using a 3 MHz matrix array transducer.
%
%   PARALLEL COMPUTING:
%   ------------------
%   SIMUS3 calls the function PFIELD3. If you have the Parallel Computing
%   Toolbox, SIMUS3 can execute several PFIELD3 in parallel. If this option
%   is activated, a parallel pool is created on the default cluster. All
%   workers in the pool are used. The X,Y,Z are splitted into NW chunks, NW
%   being the number of workers. To execute parallel computing, use:
%       [...] = SIMUS3(...,OPTIONS),
%   with OPTIONS.ParPool = true (default = false).
%
%
%   OTHER OPTIONS:
%   -------------
%      %-- FREQUENCY STEP & FREQUENCY SAMPLES --%
%   1a) Only frequency components of the transmitted signal in the range
%       [0,2fc] with significant amplitude are considered. The default
%       relative amplitude is -100 dB. You can change this value by using
%       the following:
%           [...] = SIMUS3(...,OPTIONS),
%       where OPTIONS.dBThresh is the threshold in dB (default = -100).
%   1b) The frequency step is determined automatically to avoid aliasing in
%       the time domain. This step can be adjusted with a scaling factor
%       OPTIONS.FrequencyStep (default = 1). It is not recommended to
%       modify this scaling factor in SIMUS3.
%   ---
%      %-- FULL-FREQUENCY DIRECTIVITY --%   
%   2)  By default, the directivity of the elements depends only on the
%       center frequency. This makes the calculation faster. To make the
%       directivities fully frequency-dependent, use: 
%           [...] = SIMUS3(...,OPTIONS),
%       with OPTIONS.FullFrequencyDirectivity = true (default = false).
%   ---
%       %-- ELEMENT SPLITTING --%   
%   3)  Each transducer element of the array is split into small rectangles.
%       The width and height and of these small rectangles must be small
%       enough to ensure that the far-field model is accurate. By default,
%       the elements are split into M-by-N rectangles, with M and N being
%       defined by:
%           M = ceil(element_width/smallest_wavelength);
%           N = ceil(element_height/smallest_wavelength);
%       To modify the number MN of subelements by splitting, you may adjust
%       OPTIONS.ElementSplitting, which must contain two elements. For
%       example, OPTIONS.ElementSplitting = [1 3].
%   ---
%       %-- WAIT BAR --%   
%   4)  If OPTIONS.WaitBar is true, a wait bar appears (only if the number
%       of frequency samples >10). Default is true.
%   ---
%
%
%   Notes regarding the model & REFERENCES:
%   --------------------------------------
%   Use the fonction <a href="matlab:cite")>CITE</a> to guide you in citations
%
%   1) SIMUS3 calls the function PFIELD3. It works for planar 2-D arrays.
%      It considers arrays that have identical rectangular elements on the
%      z=0 plane. Each element is split into small rectangles (if
%      required). As the sub-elements are small enough, the
%      three-dimensional radiation patterns are derived by using Fraunhofer
%      (far-field) equations.
%   2) The paper that describes the first 2-D version of SIMUS is:
%      i)   SHAHRIARI S, GARCIA D. Meshfree simulations of ultrasound vector
%           flow imaging using smoothed particle hydrodynamics. Phys Med
%           Biol, 2018;63:205011. <a
%           href="matlab:web('https://www.biomecardio.com/publis/physmedbio18.pdf')">PDF here</a>
%   3) The two-part paper that describes the theory and validation of
%      PFIELD and SIMUS is:
%      ii)  GARCIA D. SIMUS: an open-source simulator for medical ultrasound
%           imaging. Part I: theory & examples. Comput Methods Programs
%           Biomed, 2022;218:106726. <a
%           href="matlab:web('https://www.biomecardio.com/publis/cmpb22.pdf')">PDF here</a>
%      iii) CIGIER A, VARRAY F, GARCIA D. SIMUS: an open-source simulator
%           for medical ultrasound imaging. Part II:comparison with four
%           simulators. Comput Methods Programs Biomed, 2022;220:106774. <a
%           href="matlab:web('https://www.biomecardio.com/publis/cmpb22a.pdf')">PDF here</a>
%   3) The paper that describes the theory and validation of PFIELD3 and
%      SIMUS3 is:
%      iv)  GARCIA D, VARRAY F. SIMUS3: an open-source simulator for 3-D ultrasound imaging.
%           Comput Methods Programs Biomed, 2024;250:108169. <a
%           href="matlab:web('https://www.biomecardio.com/publis/cmpb24.pdf')">PDF here</a>
%
%
%   Example:
%   -------
%   %--- Generate RF signals using a matrix transducer ---%
%   %-- 3-MHz matrix array with 32x32 elements
%   param = [];
%   param.fc = 3e6;
%   param.bandwidth = 70;
%   param.width = 250e-6;
%   param.height = 250e-6;
%   %-- Position of the elements (pitch = 300 microns)
%   pitch = 300e-6;
%   [xe,ye] = meshgrid(((1:32)-16.5)*pitch);
%   param.elements = [xe(:).'; ye(:).'];
%   %-- Focus position
%   x0 = 0; y0 = 0; z0 = 3e-2;
%   %-- Transmit time delays using TXDELAY3
%   dels = txdelay3(x0,y0,z0,param);
%   %-- Create random scatterers
%   N = 100;
%   x = 2*(rand(1,N)-0.5)*4e-3;
%   y = 2*(rand(1,N)-0.5)*4e-3;
%   z = rand(1,N)*6e-2;
%   RC = hypot(rand(1,N),rand(1,N));
%   %-- Simulate RF signals
%   [RF,param] = simus3(x,y,z,RC,dels,param);
%   %-- Display the elements and the scatterers
%   figure
%   scatter3(x*1e3,y*1e3,z*1e3,30,RC,'filled')
%   colormap(cool)
%   hold on
%   scatter3(xe*1e3,ye*1e3,0*xe,3,'b','filled')
%   axis equal, box on
%   set(gca,'zdir','reverse')
%   zlabel('[mm]')
%   title([int2str(N) ' scatterers'])
%   %-- Display the position of the elements
%   figure, hold on
%   plot(xe*1e3,ye*1e3,'ko','MarkerFaceColor','c')
%   xlabel('x [mm]'), ylabel('y [mm]')
%   axis square
%   %-- Choose 4 elements randomly
%   n = sort(randi(1024,1,4));
%   plot(xe(n)*1e3,ye(n)*1e3,'ro','MarkerFaceColor','r')
%   for k = 1:4
%       text(xe(n(k))*1e3+0.3,ye(n(k))*1e3,int2str(n(k)),...
%           'Color','r','BackgroundColor','w')
%   end
%   title('32{\times}32 elements')
%   %-- Display their RF signals
%   figure
%   tl = tiledlayout(4,1);
%   title(tl,'RF signals')
%   RF = RF/max(RF(:,n),[],'all');
%   for k = 1:4
%       nexttile
%       plot((0:size(RF,1)-1)/param.fs*1e6,RF(:,n(k)))
%       title(['Element #' int2str(n(k))])
%       ylim([-1 1])
%   end
%   
%
%   This function is part of <a
%   href="matlab:web('https://www.biomecardio.com/MUST')">MUST</a> (Matlab UltraSound Toolbox).
%   MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later
%
%   See also SIMUS, PFIELD3, TXDELAY3, GETPARAM, GETPULSE, CITE.
%
%   -- Damien Garcia -- 2022/10, last update 2025/01/09
%   website: <a
%   href="matlab:web('https://www.biomecardio.com')">www.BiomeCardio.com</a>

if nargin==0
    if nargout>0
        [RF,param] = RunTheExample;
    else
        RunTheExample;
    end
    return
end

narginchk(6,7)
nargoutchk(0,3)

%-- Input variables: X,Y,Z,DELAYS,PARAM,OPTIONS
x = varargin{1};
switch nargin
    case 6 % simus(X,Y,Z,RC,DELAYS,PARAM)
        y = varargin{2};
        z = varargin{3};
        RC = varargin{4};
        delaysTX = varargin{5};
        param = varargin{6};
        options = [];
    otherwise % simus(X,Y,Z,RC,DELAYS,PARAM,OPTIONS)
        y = varargin{2};
        z = varargin{3};
        RC = varargin{4};
        delaysTX = varargin{5};
        param = varargin{6};
        options = varargin{7};
end

%-- X,Y,Z size
assert(isequal(size(x),size(y),size(z),size(RC)),...
    'X, Y, Z, and RC must be of same size.')
if isempty(x), RF = []; RFspectrum = []; return, end


%------------------------%
% CHECK THE INPUT SYNTAX % 
%------------------------%


param = IgnoreCaseInFieldNames(param);
options = IgnoreCaseInFieldNames(options);
options.CallFun = 'simus3';

%-- Wait bar
if ~isfield(options,'WaitBar')
    options.WaitBar = true;
end
assert(isscalar(options.WaitBar) && islogical(options.WaitBar),...
    'OPTIONS.WaitBar must be a logical scalar (true or false).')

%-- Parallel pool
if ~isfield(options,'ParPool')
    options.ParPool = false;
end

%-- Check if syntax errors may appear when using PFIELD3
try
    opt = options;
    opt.ParPool = false;
    opt.WaitBar = false;
    [~,param] = pfield3([],[],[],delaysTX,param,opt);
catch ME
    throw(ME)
end

%-- Sampling frequency (in Hz)
if ~isfield(param,'fs')
    param.fs = 4*param.fc; % default
end
assert(param.fs>=4*param.fc,'PARAM.fs must be >= 4*PARAM.fc.')

NumberOfElements = size(param.elements,2); % number of array elements

%-- Receive delays (in s)
if ~isfield(param,'RXdelay')
    param.RXdelay = zeros(1,NumberOfElements);
else
    assert(isvector(param.RXdelay) && isnumeric(param.RXdelay),...
        'PARAM.RXdelay must be a vector')
    assert(numel(param.RXdelay)==NumberOfElements,...
        'PARAM.RXdelay must be of length = (number of elements)')
    param.RXdelay = reshape(param.RXdelay,1,NumberOfElements);
end

%-- dB threshold (in dB: faster computation if lower value)
if ~isfield(options,'dBThresh')
    options.dBThresh = -100; % default is -100dB in SIMUS3
end
assert(isscalar(options.dBThresh) && isnumeric(options.dBThresh) &&...
    options.dBThresh<0,'OPTIONS.dBThresh must be a negative scalar.')

%-- Frequency step (scaling factor)
% The frequency step is determined automatically. It is tuned to avoid
% aliasing in the temporal domain. The frequency step can be adjusted by
% using a scaling factor. For a smoother result, you may use a scaling
% factor<1.
if ~isfield(options,'FrequencyStep')
    options.FrequencyStep = 1;
end
assert(isscalar(options.FrequencyStep) &&...
    isnumeric(options.FrequencyStep) && options.FrequencyStep>0,...
    'OPTIONS.FrequencyStep must be a positive scalar.')
if options.FrequencyStep>1
    warning('MUST:FrequencyStep',...
            'OPTIONS.FrequencyStep is >1: aliasing may be present!')
end


%-------------------------------%
% end of CHECK THE INPUT SYNTAX %
%-------------------------------%


%-- Centers of the tranducer elements (x- and y-coordinates)
xe = param.elements(1,:);
ye = param.elements(2,:);

%-- Maximum distance
d2 = (x(:)-xe).^2 + (y(:)-ye).^2 + z(:).^2;
maxD = max(sqrt(d2(:))); % maximum element-scatterer distance
clear d2
if isfinite(param.TXnow)
    [~,tp] = getpulse(param,2); % two-way pulse
    maxD = maxD + tp(end)*param.c; % add the pulse length
end

%-- Split x, y, z and RC if using a PARALLEL POOL of workers
assert(isscalar(options.ParPool) && islogical(options.ParPool),...
    'OPTIONS.ParPool must be a logical scalar (true or false).')
options.ParPool = options.ParPool &...
    license('test','Distrib_Computing_Toolbox');
if options.ParPool
    pool = gcp;
    NW = pool.NumWorkers; Nx = numel(x);
    dim1Dist = [ones(1,NW-1)*floor(Nx/NW) Nx-(NW-1)*floor(Nx/NW)];
    x = mat2cell(x(:),dim1Dist,1);
    y = mat2cell(y(:),dim1Dist,1);
    z = mat2cell(z(:),dim1Dist,1);
    RC = mat2cell(RC(:),dim1Dist,1);
end

%-- FREQUENCY SAMPLES
% to avoid aliasing in the time domain:
df = 1/2/(2*maxD/param.c + max(delaysTX+param.RXdelay,[],'all'));
df = df*options.FrequencyStep;
Nf = 2*ceil(param.fc/df)+1; % number of frequency samples


%-- Run PFIELD3 to calculate the RF spectra
RFspectrum = zeros(Nf,NumberOfElements); % will contain the RF spectra
options.FrequencyStep = df;
%- run PFIELD3 in a parallel pool (NW workers)
if options.ParPool
    options.WaitBar = false;
    spmd(NW)
        options.RC = RC{spmdIndex};
        [~,~,RFsp,idx] = pfield3(x{spmdIndex},y{spmdIndex},z{spmdIndex},...
            delaysTX,param,options);
    end
    % sum the NW spectra (RFsp is a composite object)
    for k = 1:NW
        RFspectrum(idx{k},:) = RFspectrum(idx{k},:) + RFsp{k};
    end
else
    %- no parallel pool 
    options.RC =  RC;
    [~,~,RFsp,idx] = pfield3(x,y,z,delaysTX,param,options);
    RFspectrum(idx,:) = RFsp;
end

%-- RF signals (in the time domain)
nf = ceil(param.fs/2/param.fc*(Nf-1));
RF = ifft(conj(RFspectrum),nf,'symmetric');
RF = RF(1:floor(nf/2),:);

%-- Zeroing the very small values
RelThresh = 1e-5; % -100 dB
tmp = @(RelRF) 0.5*(1+tanh((RelRF-RelThresh)/(RelThresh/10)));
tmp = @(RelRF) round(tmp(RelRF)/(RelThresh/10))*(RelThresh/10);
RF = RF.*tmp(abs(RF)/(eps+max(abs(RF(:)))));

end



function structArray = IgnoreCaseInFieldNames(structArray)

switch inputname(1)
    case 'param'
        fieldLIST = {'attenuation','baffle','bandwidth','c','fc',...
            'fnumber','focus','fs','height','kerf','movie','Nelements',...
            'passive','pitch','radius','RXangle','RXdelay',...
            'TXapodization','TXdelay','TXfreqsweep','TXnow','t0','width'};
    case 'options'
        if isstruct(structArray)
            fieldLIST = {'dBThresh','ElementSplitting',...
                'FullFrequencyDirectivity','FrequencyStep','ParPool',...
                'WaitBar'};
        else
            return
        end
end

OldFieldNames = fieldnames(structArray);
tmp = lower(OldFieldNames);
assert(length(tmp)==length(unique(tmp)),...
    ['The structure ' upper(inputname(1)),...
    ' contains duplicate field names (when ignoring case).'])

[idx,loc] = ismember(lower(fieldLIST),tmp);
idx = find(idx); loc = loc(idx);
for k = 1:length(idx)
    tmp = eval(['structArray.' OldFieldNames{loc(k)}]); %#ok
    structArray = rmfield(structArray,OldFieldNames{loc(k)});
    eval(['structArray.' fieldLIST{idx(k)} ' = tmp;']) %#ok
end

end


function [RF,param] = RunTheExample

%-- Generate RF signals using a matrix transducer

% 3-MHz matrix array with 32x32 elements
param.fc = 3e6;
param.bandwidth = 70;
param.width = 250e-6;
param.height = 250e-6;

% Position of the elements (pitch = 300 microns)
pitch = 300e-6;
[xe,ye] = meshgrid(((1:32)-16.5)*pitch);
param.elements = [xe(:).'; ye(:).'];

% Focus position
x0 = 0; y0 = 0; z0 = 3e-2;

% Transmit time delays
dels = txdelay3(x0,y0,z0,param);

% 50 random scatterers
N = 100;
x = 2*(rand(1,N)-0.5)*4e-3;
y = 2*(rand(1,N)-0.5)*4e-3;
z = rand(1,N)*6e-2;
RC = hypot(rand(1,N),rand(1,N));

% Simulate RF signals
param.fs = 10*param.fc; % sampling frequency
[RF,param] = simus3(x,y,z,RC,dels,param);

% Display the elements and the scatterers
figure
scatter3(x*1e3,y*1e3,z*1e3,30,RC,'filled')
colormap(cool)
hold on
scatter3(xe(:)*1e3,ye(:)*1e3,0*xe(:),3,'b','filled')
axis equal, box on
set(gca,'zdir','reverse')
zlabel('[mm]')
title([int2str(N) ' scatterers'])

% Display the position of the elements
figure, hold on
plot(xe*1e3,ye*1e3,'ko','MarkerFaceColor','c')
xlabel('x [mm]'), ylabel('y [mm]')
axis square

% Choose 4 elements randomly
n = sort(randi(1024,1,4));
plot(xe(n)*1e3,ye(n)*1e3,'ro','MarkerFaceColor','r')
for k = 1:4
    text(xe(n(k))*1e3+0.3,ye(n(k))*1e3,int2str(n(k)),...
        'Color','r','BackgroundColor','w')
end
title('32{\times}32 elements')

% Display their RF signals
figure
tl = tiledlayout(4,1);
title(tl,'RF signals')
RF = RF/max(RF(:,n),[],'all');
for k = 1:4
    nexttile
    plot((0:size(RF,1)-1)/param.fs*1e6,RF(:,n(k)))
    title(['Element #' int2str(n(k))])
    ylim([-1 1])
end

end


