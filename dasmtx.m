function [M,param,dTX] = dasmtx(SIG,x,z,varargin)

%DASMTX   Delay-and-sum matrix
%   M = DASMTX(SIG,X,Z,DELAYS,PARAM) returns the numel(X)-by-numel(SIG)
%   delay-and-sum DAS matrix. The matrix M can be used to beamform SIG (RF
%   or I/Q signals) at the points specified by X and Z.
%
%   Try it: enter "dasmtx" in the command window for an example.
%
%   Because the signals in SIG are not required (only its size is needed)
%   to create M, the following syntax is recommended:
%       M = DASMTX(size(SIG),X,Z,DELAYS,PARAM)
%   !IMPORTANT! -- With this syntax, use M = DASMTX(1i*size(SIG),...) to
%   return a complex DAS matrix for I/Q data.
%
%   DASMTX returns the same results as DAS.
%       1) using DAS:
%           bfSIG = das(SIG,x,z,delays,param,method);
%       2) using DASMTX:
%           M = dasmtx(size(SIG),x,z,delays,param,method);
%           bfSIG = M*SIG(:);
%           bfSIG = reshape(bfSIG,size(x));
%
%   DELAYS are the transmit time delays (in s). The number of elements in
%   DELAYS must be the number of elements in the array (which is equal to
%   size(SIG,2)). If a sub-aperture was used during transmission, use
%   DELAYS(i) = NaN if element #i of the linear array was off.
%
%   PARAM is a structure that contains the parameter values required for
%   DAS beamforming (see below for details).
%
%   M is a large sparse matrix. Computing M can be much more cost-effective
%   than using DAS if you need to beamform several SIG matrices, because
%   M needs to be determined only once.
%
%   Let us consider that a series SIG{1}, SIG{2} ... SIG{N} of ultrasound
%   matrices have been generated by sending similar wavefronts with the
%   same array. These signals SIG{i} are stacked in a 3D array sig3D so
%   that sig3D(:,:,i) = SIG{i}. To beamform these data with a delay-and-sum
%   approach, the following can be used:
%       M = dastmtx([size(sig3D,1) size(sig3D,2)],x,z,delays,param);
%       % (or M = dastmtx(1i*[size(sig3D,1) size(sig3D,2)],...) for I/Q data)
%       bfSIG3D = M*reshape(sig3D,[],size(sig3D,3));
%       bfSIG3D = reshape(bfSIG3D,size(x,1),size(x,2),[]);
%
%   You can also consider saving the DAS matrix M in a MAT file and loading
%   it when needed. The previous syntax can be much faster than:
%       for k = 1:N
%           bfSIG{k} = das(SIG{k},x,z,delays,param);
%       end
%
%   DASMTX(SIG,X,Z,PARAM) uses DELAYS = param.TXdelay.
%
%   DASMTX(...,METHOD) specifies the interpolation method. The available
%   methods are decribed in NOTE #3 below.
%
%   [M,PARAM] = DASMTX(...) also returns the structure PARAM with the
%   default values.
%
%   ---
%   NOTE #1: X- and Z-axes
%   The migrated signals are calculated at the points specified by (X,Z).
%   Conventional axes are used:
%   i) For a LINEAR array, the X-axis is PARALLEL to the transducer and
%      points from the first (leftmost) element to the last (rightmost)
%      element (X = 0 at the CENTER of the transducer). The Z-axis is
%      PERPENDICULAR to the transducer and points downward (Z = 0 at the
%      level of the transducer, Z increases as depth increases).
%   ii) For a CONVEX array, the X-axis is parallel to the chord and Z = 0
%       at the level of the chord.
%   ---
%   NOTE #2: DASMTX uses a standard delay-and-sum.
%   ---
%   NOTE #3: Interpolation methods
%   By default DASMTX uses a linear interpolation to generate the DAS
%   matrix. To specify the interpolation method, use DASMTX(...,METHOD),
%   with METHOD being:
%      'nearest'   - nearest neighbor interpolation
%      'linear'    - (default) linear interpolation
%      'quadratic' - quadratic interpolation
%      'lanczos3'  - 3-lobe Lanczos (windowed sinc) interpolation
%      '5points'   - 5-point least-squares parabolic interpolation
%      'lanczos5'  - 5-lobe Lanczos (windowed sinc) interpolation
%
%   The linear interpolation (it is a 2-point method) returns a matrix
%   twice denser than the nearest-neighbor interpolation. It is 3, 4, 5, 6
%   times denser for 'quadratic', 'lanczos3', '5points', 'lanczos5',
%   respectively (they are 3-to-6-point methods).
%   ---
%
%   PARAM is a structure that contains the following fields:
%   -------------------------------------------------------
%   1)  PARAM.fs: sampling frequency (in Hz, REQUIRED)
%   2)  PARAM.pitch: pitch of the transducer (in m, REQUIRED)
%   3)  PARAM.fc: center frequency (in Hz, REQUIRED for I/Q signals)
%   4)  PARAM.radius: radius of curvature (in m, default = Inf, linear array)
%   5)  PARAM.TXdelay: transmission delays (in s, required if DELAYS is not given)
%   6)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
%   7)  PARAM.t0: start time for reception (in s, default = 0 s)
%
%   A note on the f-number
%   ----------------------
%   The f-number is defined by the ratio (depth)/(aperture size). A null
%   f-number (PARAM.fnumber = 0) means that the full aperture is used
%   during DAS-beamforming. This might be a suboptimal strategy since the
%   array elements have some directivity.
%
%   Use PARAM.fnumber = [] to obtain an "optimal" f-number, which is
%   estimated from the element directivity (and depends on fc, bandwidth,
%   element width):
%
%   8)  PARAM.fnumber: reception f-number (default = 0, i.e. full aperture)
%   9)  PARAM.width: element width (in m, REQUIRED if PARAM.fnumber = [])
%        or PARAM.kerf: kerf width (in m, REQUIRED if PARAM.fnumber = [])
%        note: width = pitch-kerf
%   10) PARAM.bandwidth: pulse-echo 6dB fractional bandwidth (in %)
%            The default is 75% (used only if PARAM.fnumber = []).
%
%   Advanced option for vector Doppler (Reception angle):
%   ---------------------------------------------------
%   11) PARAM.RXangle: reception angles (in rad, default = 0)
%       This option can be used for vector Doppler. Beamforming with at
%       least two (sufficiently different) reception angles enables
%       different Doppler directions and, in turn, vector Doppler.
%
%   Passive imaging
%   ---------------
%   12) PARAM.passive: must be true for passive imaging (i.e. no transmit).
%       The default is false.
%
%
%   REFERENCES:
%   ----------
%   1) If you use DAS or DASMTX, please cite:
%      V Perrot, M Polichetti, F Varray, D Garcia. So you think you can
%      DAS? A viewpoint on delay-and-sum beamforming. Ultrasonics 111,
%      106309. <a
%      href="matlab:web('https://www.biomecardio.com/publis/ultrasonics21.pdf')">PDF here</a>
%   2) If you use PARAM.fnumber = [], i.e. automatic f-number, please cite:
%      D Garcia, M Tamraoui, F Varray. Think twice before f-numbering.
%      Ultrasonics 138, 107222. <a
%      href="matlab:web('https://www.biomecardio.com/publis/ultrasonics24.pdf')">PDF here</a>
%   3) If you use PARAM.RXangle for vector Doppler, please also cite:
%      Madiena C, Faurie J, Por√©e J, Garcia D. Color and vector flow
%      imaging in parallel ultrasound with sub-Nyquist sampling. IEEE Trans
%      Ultrason Ferroelectr Freq Control, 2018;65:795-802. <a
%      href="matlab:web('https://www.biomecardio.com/publis/ieeeuffc18a.pdf')">PDF here</a>
%
%
%   Example:
%   -------
%   %-- Generate RF signals using a phased-array transducer
%   % Phased-array @ 2.7 MHz:
%   param = getparam('P4-2v');
%   % TX time delays (80-degree-wide diverging wave)
%   dels = txdelay(param,0,80/180*pi);
%   % Scatterers' position:
%   xs = [(-1:0.5:1)*4e-2 zeros(1,4)];
%   zs = [ones(1,5)*6e-2 (2:2:8)*1e-2];
%   % Backscattering coefficient
%   BSC = ones(1,9);
%   % RF signals:
%   param.fs = 4*param.fc; % sampling frequency
%   RF = simus(xs,zs,BSC,dels,param);
%   % Plot the RF signals
%   subplot(121)
%   plot((RF(:,1:7:64)/max(RF(:))+(1:10)*2)',...
%      (0:size(RF,1)-1)/param.fs*1e6,'k')
%   set(gca,'XTick',(1:10)*2,'XTickLabel',int2str((1:7:64)'))
%   title('RF signals')
%   xlabel('Element number'), ylabel('time (\mus)')
%   xlim([0 22]), axis ij
%
%   %-- Demodulation and beamforming
%   % Demodulation
%   IQ = rf2iq(RF,param);
%   % Beamforming 256x128 80-degrees wide polar grid
%   [x,z] = impolgrid([256 128],9e-2,80/180*pi,param);
%   % DAS matrix and beamformed IQ
%   Mdas = dasmtx(1i*size(IQ),x,z,dels,param);
%   IQb = reshape(Mdas*IQ(:),size(x));
%   % Beamformed image
%   subplot(122)
%   pcolor(x*100,z*100,bmode(IQb))
%   colormap(gray)
%   hold on
%   plot(xs*100,zs*100,'ro')
%   hold off
%   title('Log-compressed image')
%   xlabel('[cm]'), ylabel('[cm]')
%   shading interp, axis equal ij tight
%
%
%   This function is part of MUST (Matlab UltraSound Toolbox).
%   MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later
%
%   See also DAS, SIMUS.
%
%   -- Damien Garcia -- 2017/10, last update 2024/07/03
%   website: <a
%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>

%-----------------
% HIDDEN SYNTAXES
%-----------------
%
%   13) PARAM.mean: if true, DASMTX creates a delay-and-mean matrix.



if nargin==0
    if nargout>0
        [M,param] = RunTheExample;
    else
        RunTheExample;
    end
    return
end

%------------------------%
% CHECK THE INPUT SYNTAX %
%------------------------%

assert(nargin>3,'Not enough input arguments.')
assert(nargin<7,'Too many input arguments.')
% assert(nargout<3,'Too many output arguments.')

assert(isequal(size(x),size(z)),'X and Z must of same size.')
if isequal(size(SIG),[1 2]) || isequal(size(SIG),[1 3])
    nl = abs(SIG(1)); nc = abs(SIG(2));
else
    [nl,nc,~] = size(SIG);
end

% check if we have I/Q signals
isIQ = ~isreal(SIG);

%-- Check input parameters
if ischar(varargin{end})
    method = varargin{end};
    NArg = nargin-1;
else
    method = 'linear';
    NArg = nargin;
end
%-- Check input parameters (cont'd)
if NArg==4 % DASMTX(SIG,x,z,param)
    if isstruct(varargin{1})
        param = varargin{1};
        param = IgnoreCaseInFieldNames(param);
    else
        error('The structure PARAM is required.')
    end
    assert(isfield(param,'TXdelay'),...
        'A TX delay vector (PARAM.TXdelay or DELAYS) is required.')
    delaysTX = param.TXdelay;
else % NArg=5
    %-- DASMTX(SIG,x,z,delaysTX,param)
    delaysTX = varargin{1};
    param = varargin{2};
    assert(isstruct(param),'The structure PARAM is required.')
    param = IgnoreCaseInFieldNames(param);
end
%-- Check input parameters (cont'd)
if isfield(param,'TXdelay') % DASMTX(SIG,x,z,delaysTX,param)
    assert(isequal(delaysTX(:),param.TXdelay(:)),...
        'If both specified, PARAM.TXdelay and DELAYS must be equal.')
end
assert(isequal(size(x),size(z)),'X and Z must be of same size.')

%-- Interpolation method
if ~ismember(lower(method),{'nearest','linear','quadratic','lanczos3','5points','lanczos5'})
    error('METHOD must be ''nearest'', ''linear'', ''quadratic'', ''Lanczos3'', ''5points'' or ''Lanczos5''.')
end

%-- Propagation velocity (in m/s)
if ~isfield(param,'c')
    param.c = 1540; % longitudinal velocity in m/s
end

%-- Sampling frequency (in Hz)
if ~isfield(param,'fs')
    error('A sampling frequency (PARAM.fs) is required.')
end

%-- f-number
if ~isfield(param,'fnumber')
    param.fnumber = 0; % f-number (default = full aperture)
elseif isempty(param.fnumber)
    % do nothing:
    % The f-number will be determined automatically
else
    assert(isscalar(param.fnumber) && isnumeric(param.fnumber),...
        'If not empty, PARAM.fnumber must be a scalar.')
    assert(param.fnumber>=0,...
        'PARAM.fnumber must be non-negative.')
end

%-- Acquisition start time (in s)
if ~isfield(param,'t0')
    param.t0 = 0; % acquisition start time in s
end

%-- Pitch & width or kerf (in m)
if ~isfield(param,'pitch')
    error('A pitch value (PARAM.pitch) is required.')
end
if isempty(param.fnumber)
    % NOTE:
    % An element width or a kerf width is required if the f-number is []
    if isfield(param,'width') && isfield(param,'kerf')
        assert(abs(param.pitch-param.width-param.kerf)<eps,...
            'The pitch must be equal to (kerf width + element width).')
    elseif isfield(param,'kerf')
        param.width = param.pitch-param.kerf;
    elseif isfield(param,'width')
        param.kerf = param.pitch-param.width;
    else
        error(['An element width (PARAM.width) or kerf width ',...
            '(PARAM.kerf) is required if PARAM.fnumber = [].'])
    end
    ElementWidth = param.width;
end

%-- -6dB bandwidth (in %)
if ~isfield(param,'bandwidth')
    param.bandwidth = 75;
end
if isempty(param.fnumber)
    assert(param.bandwidth>0 && param.bandwidth<200,...
        'The fractional bandwidth at -6 dB (PARAM.bandwidth, in %) must be in ]0,200[')
end

%-- Radius of curvature (in m)
% for a convex array
if ~isfield(param,'radius')
    param.radius = Inf; % default = linear array
end
RoC = param.radius;
isLINEAR = isinf(RoC);

%-- Reception angle (in rad) -- [Advanced option for vector Doppler] --
if ~isfield(param,'RXangle') || param.RXangle==0
    isRXangle = false;
    param.RXangle = 0;
else
    %- this option is not available for convex arrays
    assert(isinf(RoC),...
        'PARAM.RXangle must be 0 with a convex array.')
    %-
    isRXangle = true;
    cosRX = cos(param.RXangle);
    tanRX = tan(param.RXangle);
    if isscalar(param.RXangle)
        cosRX = cosRX*ones(size(x));
        tanRX = tanRX*ones(size(x));
    end
end

%-- Passive imaging
if ~isfield(param,'passive')
    param.passive = false;
else
    assert(islogical(param.passive),...
        'PARAM.passive must be a boolean (false or true)')
end

%-- Number of elements
if exist('delaysTX','var')
    % otherwise, we use the hidden syntax DASMTX(SIG,X,Z,PARAM,[X0 Z0])
    assert(numel(delaysTX)==nc,...
        'DELAYS and/or PARAM.TXdelay must be vectors of length size(SIG,2).')
    % Note: param.Nelements can be required in other MUST functions
    if isfield(param,'Nelements')
        assert(param.Nelements==numel(delaysTX),...
            'PARAM.TXdelay or DELAYS must be of length PARAM.Nelements.')
    end
end

%-- Center frequency (in Hz)
if isIQ
    if isfield(param,'fc')
        if isfield(param,'f0')
            assert(abs(param.fc-param.f0)<eps,...
                ['A conflict exists for the center frequency:',13,...
                'PARAM.fc and PARAM.f0 are different!'])
        end
    elseif isfield(param,'f0')
        param.fc = param.f0; % Note: param.f0 can also be used
    else
        error('A center frequency (PARAM.fc) is required with I/Q data.')
    end
    wc = 2*pi*param.fc;
end


%-------------------------------%
% end of CHECK THE INPUT SYNTAX %
%-------------------------------%



%-- Centers of the tranducer elements (x- and z-coordinates)
if isLINEAR
    % Linear array
    xe = ((0:nc-1)-(nc-1)/2)*param.pitch;
    ze = zeros(1,nc);
else
    % Convex array
    chord = 2*RoC*...
        sin(asin(param.pitch/2/RoC)*(nc-1));
    h = sqrt(RoC^2-chord^2/4);
    THe = linspace(atan2(-chord/2,h),atan2(chord/2,h),nc);
    ze = RoC*cos(THe);
    xe = RoC*sin(THe);
    ze = ze-h;
    % Note: the center of the circular segment is (0,-h)
end
% note: THe = angle of the normal to element #e with respect to the z-axis


% some parameters
fs = param.fs; % sampling frequency
c = param.c; % propagation velocity

%-- f-number (determined automatically if not given)
% The f-number is determined from the element directivity
% See paper "So you think you can DAS?"
if isempty(param.fnumber)
    lambdaMIN = c/(param.fc*(1+param.bandwidth/200));
    RXa = abs(param.RXangle);
    % Note: in Matlab, sinc(x) = sin(pi*x)/(pi*x)
    f = @(th,width,lambda)...
        abs(cos(th+RXa)*sinc(width/lambda*sin(th+RXa))-0.71);
    % Note : 0.71 = 10^(dB/20), with dB = -3
    opt = optimset('TolX',pi/100);
    alpha = fminbnd(@(th) f(th,ElementWidth,lambdaMIN),0,pi/2-RXa,opt);
    param.fnumber = 1/2/tan(alpha);
end
fNum = param.fnumber;

t0 = param.t0;
x = x(:); z = z(:);
N = numel(x);

%----
% Migration - diffraction summation (Delay & Sum, DAS)
%----

%-- TX distances
if param.passive
    % No transmission, only receive
    dTX = 0;
else

    %-- First check which elements were transmitting
    WasTransmitting = ~isnan(delaysTX);
    assert(sum(abs(diff(WasTransmitting)))<3,...
        'Multiple transmitting sub-apertures are not allowed during beamforming.')
    nTX = nnz(WasTransmitting); % number of transmitting elements

    %-- TX distances
    if nTX==1
        % Only one element was active
        dTX = hypot(xe(WasTransmitting)-x,ze(WasTransmitting)-z) + ...
            delaysTX(WasTransmitting)*c;

    elseif nTX<3
        error('If not 1, the number of neighboring transmitting elements must be at least 3.')

    else
        %-- We create a virtual transducer to calculate the TX distances.
        [xv,zv] = vxdcr(xe(WasTransmitting),ze(WasTransmitting),...
            delaysTX(WasTransmitting),c);
        dzv = diff2(xv,zv);

        % Distances between the (x,z) points and the lines normal to the
        % virtual transducer at (xv,zv)
        Dn = abs(x-xv + dzv.*(z-zv))./hypot(1,dzv);
        % idx contains the element numbers that give the smallest Dn_s
        [~,idx] = min(Dn,[],2);

        InterpMethod = 'parabolic';
        InterpMethod = 'nearest';
        switch InterpMethod
            case 'nearest'
                dTX = hypot(xv(idx)'-x,zv(idx)'-z);
            case 'parabolic'
                % parabolic peak fitting: locations of the vertices
                dTX = hypot(xv-x,zv-z);
                dTX(:,2:nc-1) = conv2(dTX,[1 0 1],'valid')/2 - ...
                    conv2(dTX,[1 0 -1],'valid').*...
                    conv2(Dn,[1 0 -1],'valid')./conv2(Dn,[2 -4 2],'valid');
                dTX = dTX((1:N)'+(idx-1)*N);
        end
    end
end

%-- RX distances
dxT = x-xe; % (is needed for calculating the f-number)
dRX = hypot(dxT,z-ze);

%-- Travel times
tau = (dTX+dRX)/c;
clear dTX

%-- Corresponding fast-time indices
idxt = (tau - t0(:)')*fs + 1;
idxt = double(idxt); % in case tau is in single precision

%-- In-range indices:
switch lower(method)
    case 'nearest', I = idxt>=1 & idxt<=nl;
    case 'linear', I = idxt>=1 & idxt<=nl-1;
    case 'quadratic', I = idxt>=1 & idxt<=nl-2;
    case 'lanczos3', I = idxt>=2 & idxt<=nl-2;
    case '5points', I = idxt>=3 & idxt<=nl-2;
    case 'lanczos5', I = idxt>=3 & idxt<=nl-3;
end

%-- Aperture (using the f-number):
if fNum>0
    if ~isRXangle
        if isfinite(RoC)
            % -- for a convex array
            Iaperture = abs(asin(dxT./dRX)-THe)<=atan(1/2/fNum);
        else
            % -- for a linear array
            % For a given location [x(k),z(k)], one has:
            % Iaperture = abs(xT-x(k)) <= z(k)/2/fNum;
            Iaperture = abs(dxT)<=(z/2/fNum);
        end

    else % [Advanced option for vector Doppler: Reception angle]
        % -- ONLY for a rectilinear array
        % For a given location [x(k),z(k)], one has:
        % Iaperture = abs(xT-x(k)-z(k)*tanRX(k)) <= z(k)/cosRX(k)/2/fNum;
        % In a compact matrix form, this yields:
        Iaperture = abs(dxT-z.*tanRX(:))<=(z./cosRX(:)/2/fNum);
    end
    I = I&Iaperture;
end
clear dRX

% subscripts to linear indices (instead of using SUB2IND)
idx = idxt + (0:nc-1)*nl;
idx = idx(I);

% weights (aperture size correction)
if isfield(param,'mean') && param.mean==true
    W = nc./sum(Iaperture,2);
    W(~isfinite(W)) = 1;
else
    W = ones(N,1);
end

%-- Let's fill in the sparse DAS matrix
switch lower(method) % Interpolation Method

    case 'nearest' %-- Nearest neighbor interpolation (1-point method)

        %-- DAS matrix
        [i,~] = find(I);
        j = round(idx);
        if isIQ % phase rotation (if I/Q signals)
            s = exp(1i*wc*tau(I));
        else
            s = 1;
        end
        s = s.*W(i);
        if isfield(param,'TransposeDASMatrix')
            % -- DASMTX has been called by the function DAS --
            %
            % The smallest DAS matrix (in terms of memory) is returned.
            % (Matlab stores sparse matrices in compressed sparse column format)
            if numel(x)>nl*nc
                param.TransposeDASMatrix = false;
                M = sparse(i,j,s,numel(x),nl*nc);
                % M is a [numel(x)]-by-[nl*nc] sparse matrix
            else
                param.TransposeDASMatrix = true;
                M = sparse(j,i,s,nl*nc,numel(x));
                % M is a [nl*nc]-by-[numel(x)] sparse matrix
            end
        else
            M = sparse(i,j,s,numel(x),nl*nc);
            % M is a [numel(x)]-by-[nl*nc] sparse matrix
        end


    case 'linear' %-- Linear interpolation (2-point method)

        idxf = floor(idx);
        idx = idxf-idx;

        %-- DAS matrix
        [i,~] = find(I);
        j = [idxf; idxf+1];
        s = [idx+1; -idx];
        s = s.*repmat(W(i),2,1);
        if isIQ % phase rotation (if I/Q signals)
            tau = tau(I);
            s = s.*exp(1i*wc*[tau;tau]);
        end
        if isfield(param,'TransposeDASMatrix')
            % -- DASMTX has been called by the function DAS --
            %
            % The smallest DAS matrix (in terms of memory) is returned.
            % (Matlab stores sparse matrices in compressed sparse column format)
            if numel(x)>nl*nc
                param.TransposeDASMatrix = false;
                M = sparse([i;i],j,s,numel(x),nl*nc);
                % M is a [numel(x)]-by-[nl*nc] sparse matrix
            else
                param.TransposeDASMatrix = true;
                M = sparse(j,[i;i],s,nl*nc,numel(x));
                % M is a [nl*nc]-by-[numel(x)] sparse matrix
            end
        else
            M = sparse([i;i],j,s,numel(x),nl*nc);
            % M is a [numel(x)]-by-[nl*nc] sparse matrix
        end


    case 'quadratic' %-- quadratic interpolation (3-point method)

        idxf = floor(idx);
        idx = idx-idxf;

        %-- DAS matrix
        [i,~] = find(I);
        j = [idxf; idxf+1; idxf+2];
        s = [(idx-1).*(idx-2)/2;
            -idx.*(idx-2);
            idx.*(idx-1)/2];
        s = s.*repmat(W(i),3,1);
        if isIQ % phase rotation (if I/Q signals)
            tau = tau(I);
            s = s.*exp(1i*wc*repmat(tau,3,1));
        end
        if isfield(param,'TransposeDASMatrix')
            % -- DASMTX has been called by the function DAS --
            %
            % The smallest DAS matrix (in terms of memory) is returned.
            % (Matlab stores sparse matrices in compressed sparse column format)
            if numel(x)>nl*nc
                param.TransposeDASMatrix = false;
                M = sparse(repmat(i,3,1),j,s,numel(x),nl*nc);
                % M is a [numel(x)]-by-[nl*nc] sparse matrix
            else
                param.TransposeDASMatrix = true;
                M = sparse(j,repmat(i,3,1),s,nl*nc,numel(x));
                % M is a [nl*nc]-by-[numel(x)] sparse matrix
            end
        else
            M = sparse(repmat(i,3,1),j,s,numel(x),nl*nc);
            % M is a [numel(x)]-by-[nl*nc] sparse matrix
        end


    case 'lanczos3' %-- 3-lobe Lanczos interpolation (4-point method)

        idxf = floor(idx);
        idx = idx-idxf;

        %-- DAS matrix
        [i,~] = find(I);
        j = [idxf-1; idxf; idxf+1; idxf+2];
        s = [sinc(idx+1).*sinc((idx+1)/2);
            sinc(idx).*sinc(idx/2);
            sinc(idx-1).*sinc((idx-1)/2);
            sinc(idx-2).*sinc((idx-2)/2)];
        s = s.*repmat(W(i),4,1);
        if isIQ % phase rotation (if I/Q signals)
            tau = tau(I);
            s = s.*exp(1i*wc*repmat(tau,4,1));
        end
        if isfield(param,'TransposeDASMatrix')
            % -- DASMTX has been called by the function DAS --
            %
            % The smallest DAS matrix (in terms of memory) is returned.
            % (Matlab stores sparse matrices in compressed sparse column format)
            if numel(x)>nl*nc
                param.TransposeDASMatrix = false;
                M = sparse(repmat(i,4,1),j,s,numel(x),nl*nc);
                % M is a [numel(x)]-by-[nl*nc] sparse matrix
            else
                param.TransposeDASMatrix = true;
                M = sparse(j,repmat(i,4,1),s,nl*nc,numel(x));
                % M is a [nl*nc]-by-[numel(x)] sparse matrix
            end
        else
            M = sparse(repmat(i,4,1),j,s,numel(x),nl*nc);
            % M is a [numel(x)]-by-[nl*nc] sparse matrix
        end


    case '5points' %-- 5-point least-squares parabolic interpolation

        idxf = floor(idx);
        idx = idx-idxf;

        %-- DAS matrix
        [i,~] = find(I);
        j = [idxf-2; idxf-1; idxf; idxf+1; idxf+2];
        idx2 = idx.^2;
        s = [1/7*idx2-1/5*idx-3/35;
            -1/14*idx2-1/10*idx+12/35;
            -1/7*idx2+17/35;
            -1/14*idx2+1/10*idx+12/35;
            1/7*idx2+1/5*idx-3/35];
        s = s.*repmat(W(i),5,1);
        if isIQ % phase rotation (if I/Q signals)
            tau = tau(I);
            s = s.*exp(1i*wc*repmat(tau,5,1));
        end
        if isfield(param,'TransposeDASMatrix')
            % -- DASMTX has been called by the function DAS --
            %
            % The smallest DAS matrix (in terms of memory) is returned.
            % (Matlab stores sparse matrices in compressed sparse column format)
            if numel(x)>nl*nc
                param.TransposeDASMatrix = false;
                M = sparse(repmat(i,5,1),j,s,numel(x),nl*nc);
                % M is a [numel(x)]-by-[nl*nc] sparse matrix
            else
                param.TransposeDASMatrix = true;
                M = sparse(j,repmat(i,5,1),s,nl*nc,numel(x));
                % M is a [nl*nc]-by-[numel(x)] sparse matrix
            end
        else
            M = sparse(repmat(i,5,1),j,s,numel(x),nl*nc);
            % M is a [numel(x)]-by-[nl*nc] sparse matrix
        end


    case 'lanczos5' %-- 5-lobe Lanczos interpolation (6-point method)

        idxf = floor(idx);
        idx = idx-idxf;

        %-- DAS matrix
        [i,~] = find(I);
        j = [idxf-2; idxf-1; idxf; idxf+1; idxf+2; idxf+3];
        s = [sinc(idx+2).*sinc((idx+2)/2);
            sinc(idx+1).*sinc((idx+1)/2);
            sinc(idx).*sinc(idx/2);
            sinc(idx-1).*sinc((idx-1)/2);
            sinc(idx-2).*sinc((idx-2)/2);
            sinc(idx-3).*sinc((idx-3)/2)];
        s = s.*repmat(W(i),6,1);
        if isIQ % phase rotation (if I/Q signals)
            tau = tau(I);
            s = s.*exp(1i*wc*repmat(tau,6,1));
        end
        if isfield(param,'TransposeDASMatrix')
            % -- DASMTX has been called by the function DAS --
            %
            % The smallest DAS matrix (in terms of memory) is returned.
            % (Matlab stores sparse matrices in compressed sparse column format)
            if numel(x)>nl*nc
                param.TransposeDASMatrix = false;
                M = sparse(repmat(i,6,1),j,s,numel(x),nl*nc);
                % M is a [numel(x)]-by-[nl*nc] sparse matrix
            else
                param.TransposeDASMatrix = true;
                M = sparse(j,repmat(i,6,1),s,nl*nc,numel(x));
                % M is a [nl*nc]-by-[numel(x)] sparse matrix
            end
        else
            M = sparse(repmat(i,6,1),j,s,numel(x),nl*nc);
            % M is a [numel(x)]-by-[nl*nc] sparse matrix
        end

end

end


function structArray = IgnoreCaseInFieldNames(structArray)

switch inputname(1)
    case 'param'
        fieldLIST = {'attenuation','baffle','bandwidth','c','fc',...
            'fnumber','fs','f0','image','kerf','Nelements','pitch',...
            'radius','RXangle','RXdelay','TXapodization', 'TXdelay',...
            'TXfreqsweep','TXnow','t0','width'};
    case 'options'
        if isstruct(structArray)
            fieldLIST = {'dBThresh','ElementSplitting',...
                'FullFrequencyDirectivity','ParPool','WaitBar'};
        else
            return
        end
end

OldFieldNames = fieldnames(structArray);
tmp = lower(OldFieldNames);
assert(length(tmp)==length(unique(tmp)),...
    ['The structure ' upper(inputname(1)),...
    ' contains duplicate field names (when ignoring case).'])

[idx,loc] = ismember(lower(fieldLIST),tmp);
idx = find(idx); loc = loc(idx);
for k = 1:length(idx)
    tmp = structArray.(OldFieldNames{loc(k)});
    structArray = rmfield(structArray,OldFieldNames{loc(k)});
    structArray.(fieldLIST{idx(k)}) = tmp;
end

end

function [xV,zV] = vxdcr(xe,ze,delaysTX,c)
%VXDCR   Virtual transducer (XDCR)
%   [xV,zV] = VXDCR returns the positions of the elements of the
%   virtual transducer.
%
%   The virtual transducer is an "equivalent" transducer assuming null
%   delays.
%
%   -- Damien Garcia -- 2023/04, last update: 2024/05/27
%                                [simplified version]

T2 = delaysTX.^2;
dT2dxe = diff2(xe,T2);
err = min(diff(xe))*1e-3;
dzedxe = diff2(xe,ze);

%-- Virtual transducer
if all(ze==0)
    % for a linear transducer
    xV = xe - 0.5*c^2*dT2dxe;
    zV = -sqrt(abs(c^2*T2-(xV-xe).^2));
else
    % for a convex array, it is not that straightforward
    xV = xe;
    tmp = sqrt(abs(c^2*T2-(xV-xe).^2));
    opt = optimset('TolFun',err,'TolX',err);
    for k = 1:length(xV)
        myfun = @(xv) (xe(k)-xv) +...
            tmp(k).*dzedxe(k) +...
            -0.5*c^2*dT2dxe(k);
        xV(k) = fzero(@(xv) myfun(xv),xV(k),opt);
    end
    zV = ze-tmp;
end

%-- Inappropriate delays generate incorrect virtual transducers
test = all(diff(xV)>0) & all((c^2*T2-(xV-xe).^2)>-err);
if ~test
    error('The delays do not allow a virtual transducer to be calculated.')
end

%-- Check if the virtual transducer is convex or concave
% https://mathworld.wolfram.com/ConvexFunction.html
idx = nchoosek(1:numel(xV),3);
lambda = (xV(idx(:,3))-xV(idx(:,2)))./(xV(idx(:,1))-xV(idx(:,2)));
alst1 = abs(lambda)<1; % keep only the data with |lambda|<1
tmp = zV(idx(alst1,3)) -...
    (lambda(alst1).*zV(idx(alst1,1)) + (1-lambda(alst1)).*zV(idx(alst1,2)));
test = max(nnz(tmp>-eps),nnz(tmp<eps))/numel(tmp)>.999;
if ~test
    warning('off','backtrace')
    warning('The virtual transducer is not convex or concave.')
    warning('on','backtrace')
end
end

function dy = diff2(x,y)
% 1st derivative of Y using a 2nd order difference method
% [simplified version: for 1-D arrays]
m = length(y);
dx = diff(x);
dy = zeros(size(y));
%-- y'(x_1)
dy(1) = (1/dx(1)+1/dx(2))*(y(2)-y(1))+...
    dx(1)/(dx(1)*dx(2)+dx(2)^2)*(y(1)-y(3));
%-- y'(x_m)
dy(m) = (1/dx(m-2)+1/dx(m-1))*(y(m)-y(m-1))+...
    dx(m-1)/(dx(m-1)*dx(m-2)+dx(m-2)^2)*(y(m-2)-y(m));
%-- y'(x_i) (i>1 & i<m)
dx1 = dx(1:m-2);
dx2 = dx(2:m-1);
y1 = y(1:m-2); y2 = y(2:m-1); y3 = y(3:m);
dy(2:m-1) = 1./(dx1.*dx2.*(dx1+dx2)).*...
    (-dx2.^2.*y1+(dx2.^2-dx1.^2).*y2+dx1.^2.*y3);
end


function [M,param] = RunTheExample

%-- Generate RF signals using a phased-array transducer

% Phased-array @ 2.7 MHz:
param = getparam('P4-2v');

% TX time delays (80-degree-wide diverging wave)
dels = txdelay(param,0,80/180*pi);

% Scatterers' position:
xs = [(-1:0.5:1)*4e-2 zeros(1,4)];
zs = [ones(1,5)*6e-2 (2:2:8)*1e-2];

% Backscattering coefficient
BSC = ones(1,9);

% RF signals:
param.fs = 4*param.fc; % sampling frequency
RF = simus(xs,zs,BSC,dels,param);

% Plot the RF signals
figure
subplot(121)
plot((RF(:,1:7:64)/max(RF(:))+(1:10)*2)',...
    (0:size(RF,1)-1)/param.fs*1e6,'k')
set(gca,'XTick',(1:10)*2,'XTickLabel',int2str((1:7:64)'))
title('RF signals')
xlabel('Element number'), ylabel('time (\mus)')
xlim([0 22]), axis ij


%-- Demodulation and beamforming

% Demodulation
IQ = rf2iq(RF,param);

% Beamforming grid
[th,r] = meshgrid(linspace(-40,40,128)/180*pi+pi/2,...
    linspace(1,9,256)*1e-2);
[x,z] = pol2cart(th,r);

% DAS matrix and beamformed IQ
M = dasmtx(1i*size(IQ),x,z,dels,param);
IQb = reshape(M*IQ(:),size(x));

% Beamformed image
subplot(122)
pcolor(x*100,z*100,bmode(IQb))
colormap(gray)
shading interp, axis equal ij tight
title('Log-compressed image')
xlabel('[cm]'), ylabel('[cm]')
hold on
% position of the scatterers (in cm)
plot(xs*100,zs*100,'ro')

end

