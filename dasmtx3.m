function [M,param] = dasmtx3(SIG,x,y,z,varargin)

%DASMTX3   Delay-and-sum matrix for 3-D imaging with a matrix array
%   M = DASMTX3(SIG,X,Y,Z,DELAYS,PARAM) returns the numel(X)-by-numel(SIG)
%   delay-and-sum DAS matrix. The matrix M can be used to beamform SIG (RF
%   or I/Q signals) at the points specified by X, Y, and Z.
%
%   Because the signals in SIG are not required (only its size is needed)
%   to create M, the following syntax is recommended:
%       M = DASMTX3(size(SIG),X,Y,Z,DELAYS,PARAM)
%   !IMPORTANT! -- With this syntax, use M = DASMTX3(1i*size(SIG),...) to
%   return a complex DAS matrix for I/Q data.
%
%   NOTE: SIG must be a 2-D or 3-D array (the 3rd dimension is ignored).
%         Or, size(SIG) must be a two- or three-component vector (the 3rd
%         component is ignored). The first dimension (i.e. each column)
%         corresponds to a single RF or I/Q signal over (fast-) time, with
%         the COLUMN #k corresponding to PARAM.elements #k.
%
%   DASMTX3 returns the same results as DAS3.
%       1) using DAS3:
%           bfSIG = das3(SIG,x,y,z,delays,param,method);
%       2) using DASMTX3:
%           M = dasmtx3(size(SIG),x,y,z,delays,param,method);
%           bfSIG = M*SIG(:);
%           bfSIG = reshape(bfSIG,size(x));
%
%   DELAYS are the transmit time delays (in s). DELAYS must be a vector or
%   matrix whose number of elements must be equal to the number of elements
%   in the array (which is equal to size(SIG,2)). If a sub-aperture was
%   used during transmission, use DELAYS(i) = NaN if element #i of the
%   linear array was off.
%
%   PARAM is a structure that contains the parameter values required for
%   DAS beamforming (see below for details).
%
%   In 3-D ultrasound imaging with a significant number of elements,
%   DASMTX3 can generate tall sparse DAS matrices when beamforming large
%   volume data! To avoid memory issues, consider chunking your datasets.
%
%   Let us consider that a series SIG{1}, SIG{2} ... SIG{N} of ultrasound
%   matrices have been generated by sending similar wavefronts with the
%   same array. To beamform these data with a delay-and-sum
%   approach, the following can be used:
%       M = dasmtx3(size(SIG),x,y,z,delays,param);
%       % (or M = dasmtx3(1i*size(SIG),...) for I/Q data)
%       for k = 1:N
%         bfSIG{k} = M*reshape(SIG{k},size(SIG{k},1),[]);
%         bfSIG{k} = reshape(bfSIG{k},size(x));
%       end
%   This syntax is much faster than:
%       for k = 1:N
%           bfSIG{k} = das3(SIG{k},x,y,z,delays,param);
%       end
%
%   DASMTX3(SIG,X,Y,Z,PARAM) uses DELAYS = param.TXdelay.
%
%   DASMTX3(...,METHOD) specifies the interpolation method. The available
%   methods are decribed in NOTE #3 below.
%
%   [M,PARAM] = DASMTX3(...) also returns the structure PARAM with the
%   default values.
%
%   ---
%   NOTE #1: X-, Y- and Z-axes
%   The migrated signals are calculated at the points specified by (X,Y,Z).
%   Conventional axes are used:
%   i) For a matrix array, the X-axis is PARALLEL to the transducer. The
%      Z-axis is PERPENDICULAR to the transducer and points downward (Z = 0
%      at the level of the transducer, Z increases as depth increases). The
%      Y-axis corresponds to the elevation direction.
%   ---
%   NOTE #2: DASMTX3 uses a standard delay-and-sum.
%   ---
%   NOTE #3: Interpolation methods
%   By default DASMTX3 uses a linear interpolation to generate the DAS
%   matrix. To specify the interpolation method, use DASMTX3(...,METHOD),
%   with METHOD being:
%      'nearest'   - nearest neighbor interpolation
%      'linear'    - (default) linear interpolation
%      'quadratic' - quadratic interpolation
%      'lanczos3'  - 3-lobe Lanczos (windowed sinc) interpolation
%      '5points'   - 5-point least-squares parabolic interpolation
%      'lanczos5'  - 5-lobe Lanczos (windowed sinc) interpolation
%
%   The linear interpolation (it is a 2-point method) returns a matrix
%   twice denser than the nearest-neighbor interpolation. It is 3, 4, 5, 6
%   times denser for 'quadratic', 'lanczos3', '5points', 'lanczos5',
%   respectively (they are 3-to-6-point methods).
%   ---
%
%   PARAM is a structure that contains the following fields:
%   -------------------------------------------------------
%   1)  PARAM.fs: sampling frequency (in Hz, REQUIRED)
%   2)  PARAM.elements: coordinates of the transducer elements (in m, REQUIRED)
%       PARAM.elements must contain the x- and y-coordinates of the
%       transducer elements (the z-coordinates are zero if not given). It
%       must be a matrix with 2 (or 3) rows corresponding to the
%       x- and y-coordinates (and optionally z), respectively.
%   3)  PARAM.fc: center frequency (in Hz, REQUIRED for I/Q signals)
%   4)  PARAM.TXdelay: transmission delays (in s, required if DELAYS is not given)
%   5)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
%   6)  PARAM.t0: start time for reception (in s, default = 0 s)
%   7)  PARAM.fnumber: reception f-number (default = [0 0], i.e. full aperture)
%       PARAM.fnumber(1) = reception f-number in the azimuthal x-direction.
%       PARAM.fnumber(2) = reception f-number in the elevation y-direction.
%
%   Passive imaging
%   ---------------
%   8)  PARAM.passive: must be true for passive imaging (i.e. no transmit).
%       The default is false.
%
%   This function is part of MUST (Matlab UltraSound Toolbox).
%   MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later
%
%   See also DAS, DASMTX, TXDELAY3, SIMUS3.
%
%   -- Damien Garcia -- last update 2025/01/22
%   website: <a
%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>


%------------------------%
% CHECK THE INPUT SYNTAX %
%------------------------%

assert(nargin>4,'Not enough input arguments.')
assert(nargin<8,'Too many input arguments.')
assert(nargout<3,'Too many output arguments.')

assert(isequal(size(x),size(y),size(z)),'X, Y and Z must of same size.')
if isequal(size(SIG),[1 2]) || isequal(size(SIG),[1 3])
    nl = abs(SIG(1)); nc = abs(SIG(2));
else
    [nl,nc,~] = size(SIG);
end

% check if we have I/Q signals
isIQ = ~isreal(SIG);

%-- Check input parameters
if ischar(varargin{end})
    method = varargin{end};
    NArg = nargin-1;
else
    method = 'linear';
    NArg = nargin;
end

if NArg==5 % DASMTX3(SIG,x,y,z,param)
    if isstruct(varargin{1})
        param = varargin{1};
        param = IgnoreCaseInFieldNames(param);
    else
        error('The structure PARAM is required.')
    end
    assert(isfield(param,'TXdelay'),...
        'A TX delay vector (PARAM.TXdelay or DELAYS) is required.')
    delaysTX = param.TXdelay;
else % NArg=6: DASMTX3(SIG,x,y,z,delaysTX,param)
    delaysTX = varargin{1};
    param = varargin{2};
    assert(isstruct(param),'The structure PARAM is required.')
    param = IgnoreCaseInFieldNames(param);
end
if isfield(param,'TXdelay') % DASMTX3(SIG,x,y,z,delaysTX,param)
    assert(isequal(delaysTX(:),param.TXdelay(:)),...
        'If both specified, PARAM.TXdelay and DELAYS must be equal.')
end

%-- Interpolation method
if ~ismember(lower(method),{'nearest','linear','quadratic','lanczos3','5points','lanczos5'})
    error('METHOD must be ''nearest'', ''linear'', ''quadratic'', ''Lanczos3'', ''5points'' or ''Lanczos5''.')
end

%-- Propagation velocity (in m/s)
if ~isfield(param,'c')
    param.c = 1540; % longitudinal velocity in m/s
end

%-- Sampling frequency (in Hz)
if ~isfield(param,'fs')
    error('A sampling frequency (PARAM.fs) is required.')
end

%-- f-number
if ~isfield(param,'fnumber')
    param.fnumber = [0 0]; % f-number (default = full aperture)
elseif param.fnumber==0
    param.fnumber = [0 0];
elseif ~isempty(param.fnumber)
    assert(numel(param.fnumber)==2,...
        'PARAM.fnumber must contain two elements.')
    assert(isnumeric(param.fnumber),...
        'PARAM.fnumber must be numeric.')
    assert(all(param.fnumber>=0),...
        'PARAM.fnumber must be non-negative.')
end

%-- Acquisition start time (in s)
if ~isfield(param,'t0')
    param.t0 = 0; % acquisition start time in s
end

%-- Radius of curvature (in m)
% for a convex array
if ~isfield(param,'radius')
    param.radius = Inf; % default = linear array
else
    assert(isinf(param.radius),...
        'DASMTX3 does not address matrix convex arrays.')
end

%-- Reception angle (in rad) -- [option not available in DASMTX3] --
if ~isfield(param,'RXangle')
    param.RXangle = 0;
else
    assert(param.RXangle==0,...
        'PARAM.RXangle must be 0 with DASMTX3.')
end

%-- Passive imaging
if ~isfield(param,'passive')
    param.passive = false;
else
    assert(islogical(param.passive),...
        'PARAM.passive must be a boolean (false or true)')
end

%-- Coordinates of the transducer elements (xe,ye,ze)
assert(isfield(param,'elements'),...
    ['PARAM.elements must contain the x- and y-locations ',...
    'of the transducer elements.'])
assert(ismatrix(param.elements) &&...
    any(ismember([2 3],size(param.elements,1))),...
    ['PARAM.elements must be a 2 (or 3)-row matrix that contains the ',...
    'x, y (and optionally z)-coordinates of the transducer elements.'])
xe = param.elements(1,:);
ye = param.elements(2,:);
if size(param.elements,1)==3
    ze = param.elements(3,:);
else
    ze = zeros(size(xe));
end

%-- Number of elements
assert(numel(delaysTX)==nc,...
    'DELAYS and/or PARAM.TXdelay must be vectors of length size(SIG,2).')
% Note: param.Nelements can be required in other functions of the
%       Matlab Ultrasound Toolbox
if isfield(param,'Nelements')
    assert(param.Nelements==numel(delaysTX),...
        'PARAM.TXdelay or DELAYS must be of length PARAM.Nelements.')
end
assert(numel(xe)==nc,...
    'The number of elements must be equal to size(SIG,2).')

%-- Center frequency (in Hz)
if isIQ
    if isfield(param,'fc')
        if isfield(param,'f0')
            assert(abs(param.fc-param.f0)<eps,...
                ['A conflict exists for the center frequency:',13,...
                'PARAM.fc and PARAM.f0 are different!'])
        end
    elseif isfield(param,'f0')
        param.fc = param.f0; % Note: param.f0 can also be used
    else
        error('A center frequency (PARAM.fc) is required with I/Q data.')
    end
    wc = 2*pi*param.fc;
end


%-------------------------------%
% end of CHECK THE INPUT SYNTAX %
%-------------------------------%



% some parameters
fs = param.fs; % sampling frequency
c = param.c; % propagation velocity


%-- f-number (determined automatically if not given)
% The f-number is determined from the element directivity
% See the paper "So you think you can DAS?"
if isempty(param.fnumber)
    lambdaMIN = c/(param.fc*(1+param.bandwidth/200));
    RXa = abs(param.RXangle);
    % Note: in Matlab, sinc(x) = sin(pi*x)/(pi*x)
    f = @(th,width,lambda)...
        abs(cos(th+RXa)*sinc(width/lambda*sin(th+RXa))-0.71);
    % Note : 0.71 = 10^(dB/20), with dB = -3
    opt = optimset('TolX',pi/100);
    alpha = fminbnd(@(th) f(th,param.width,lambdaMIN),0,pi/2-RXa,opt);
    param.fnumber(1) = 1/2/tan(alpha);
    alpha = fminbnd(@(th) f(th,param.height,lambdaMIN),0,pi/2-RXa,opt);
    param.fnumber(2) = 1/2/tan(alpha);    
end
fNum = param.fnumber;


t0 = param.t0;
x = x(:); y = y(:); z = z(:);
Nx = numel(x);

%----
% Migration - diffraction summation (Delay & Sum, DAS)
%----

%-- RX distances
dxT = x-xe; dyT = y-ye; dzT = z-ze;
dRX = sqrt(dxT.^2+dyT.^2+dzT.^2);

%-- TX distances
if param.passive
    % No transmission, only receive
    dTX = 0;
else

    %-- First check which elements were transmitting
    WasTransmitting = ~isnan(delaysTX);
    nTX = nnz(WasTransmitting); % number of transmitting elements

    %-- TX distances
    if nTX==1
        % Only one element was active
        dTX = sqrt((xe(WasTransmitting)-x)^2 +...
            (ye(WasTransmitting)-y)^2 + (ze(WasTransmitting)-z)^2) + ...
            delaysTX(WasTransmitting)*c;

    elseif nTX<3
        error('If not 1, the number of transmitting elements must be at least 3.')

    else
        %-- We create a virtual transducer to calculate the TX distances.
        [xv,yv,zv] = vxdcr3(xe(WasTransmitting),ye(WasTransmitting),...
            delaysTX(WasTransmitting),c);

        % Note:
        % The transmission distance for a given point P (x,y,z) is defined
        % as the distance between P and the virtual transducer. To
        % calculate this distance, we determine the line perpendicular to
        % the virtual transducer that passes through P. This line
        % intersects the virtual transducer at the point (xv,yv,zv). The
        % transmission distance is then computed as d(x-xv,y-yv,z-zv). If
        % no perpendicular line passes through P (i.e., P is outside the
        % field), the closest line to P is used.

        % Delaunay triangulation
        tri = delaunay(xe(WasTransmitting),ye(WasTransmitting));        

        % unit normal vectors for each triangle
        tr = triangulation(tri,xv(:),yv(:),zv(:));
        fN = faceNormal(tr); % components of the normal vectors

        % lengths of the sides of the triangles
        s1 = sqrt((xv(tri(:,2))-xv(tri(:,3))).^2 +...
            (yv(tri(:,2))-yv(tri(:,3))).^2 +...
            (zv(tri(:,2))-zv(tri(:,3))).^2);
        s2 = sqrt((xv(tri(:,1))-xv(tri(:,3))).^2 +...
            (yv(tri(:,1))-yv(tri(:,3))).^2 +...
            (zv(tri(:,1))-zv(tri(:,3))).^2);
        s3 = sqrt((xv(tri(:,2))-xv(tri(:,1))).^2 +...
            (yv(tri(:,2))-yv(tri(:,1))).^2 +...
            (zv(tri(:,2))-zv(tri(:,1))).^2);

        % semi-perimeters and areas (Heron's formula)
        s = (s1+s2+s3)/2;
        A = sqrt(s.*(s-s1).*(s-s2).*(s-s3));

        % "equilaterality" of the triangles (= 2*inradius/circumradius)
        % 1 if equilateral, 0 if degenerate
        E = 8*A.^2./(s.*s1.*s2.*s3);
        E = E';

        % map matrix from triangles to nodes
        nt = size(tri,1);
        Mtn = sparse(repmat((1:nt)',3,1),tri,1,size(tri,1),nc);

        % weighted mean of the normal vector components
        % (we have several triangles for each node)
        fNx = (Mtn'*(fN(:,1).*E))./(Mtn'*E);
        fNy = (Mtn'*(fN(:,2).*E))./(Mtn'*E);
        fNz = (Mtn'*(fN(:,3).*E))./(Mtn'*E);

        % squared distances between the (x,y,z) points and the lines normal
        % to the virtual transducer at (xv,yv,zv)
        Dn2 = abs(((y-yv).*fNz'-(z-zv).*fNy').^2 +...
            ((z-zv).*fNx'-(x-xv).*fNz').^2 +...
            ((x-xv).*fNy'-(y-yv).*fNx').^2);
        % idx contains the element numbers that give the smallest Dn2_s
        [~,idx] = min(Dn2,[],2);
        clear Dn2

        dTX = sqrt((xv(idx)'-x).^2 + (yv(idx)'-y).^2 + (zv(idx)'-z).^2);
    end
end

clear x y z

%-- Travel times
tau = (dTX+dRX)/c;
clear dTX dRX

%-- Corresponding fast-time indices
idxt = (tau-t0(:)')*fs + 1;
idxt = double(idxt); % in case tau is in single precision

%-- In-range indices:
switch lower(method)
    case 'nearest', I = idxt>=1 & idxt<=nl;
    case 'linear', I = idxt>=1 & idxt<=nl-1;
    case 'quadratic', I = idxt>=1 & idxt<=nl-2;
    case 'lanczos3', I = idxt>=2 & idxt<=nl-2;
    case '5points', I = idxt>=3 & idxt<=nl-2;
    case 'lanczos5', I = idxt>=3 & idxt<=nl-3;
end

%-- Aperture (using the f-number):
if ~isequal(fNum(:),[0;0])
    % -- for a planar array
    Iaperture = abs(dxT)<=(abs(dzT)/2/fNum(1)) &...
        abs(dyT)<=(abs(dzT)/2/fNum(2));
    I = I&Iaperture;
end
clear dxT dyT dzT

% subscripts to linear indices (instead of using SUB2IND)
idx = idxt + (0:nc-1)*nl;
clear idxt
idx = idx(I);


%-- Let's fill in the sparse DAS matrix

if ~strcmpi(method,'nearest')
    idxf = floor(idx);
    idx = idx-idxf;
end
[i,~] = find(I);

switch lower(method) % Interpolation Method

    case 'nearest' %-- Nearest neighbor interpolation
        Npoints = 1; % 1-point method
        j = round(idx);
        s = 1;

    case 'linear' %-- Linear interpolation
        Npoints = 2; % 2-point method
        i = repmat(i,Npoints,1);
        j = [idxf; idxf+1];
        s = [-idx+1; idx];

    case 'quadratic' %-- quadratic interpolation
        Npoints = 3; % 3-point method
        i = repmat(i,Npoints,1);
        j = [idxf; idxf+1; idxf+2];
        s = [(idx-1).*(idx-2)/2;
            -idx.*(idx-2);
            idx.*(idx-1)/2];

    case 'lanczos3' %-- 3-lobe Lanczos interpolation
        Npoints = 4; % 4-point method
        i = repmat(i,Npoints,1);
        j = [idxf-1; idxf; idxf+1; idxf+2];
        s = [sinc(idx+1).*sinc((idx+1)/2);
            sinc(idx).*sinc(idx/2);
            sinc(idx-1).*sinc((idx-1)/2);
            sinc(idx-2).*sinc((idx-2)/2)];

    case '5points' %-- 5-point least-squares parabolic interpolation
        Npoints = 5; % 5-point method
        i = repmat(i,Npoints,1);
        j = [idxf-2; idxf-1; idxf; idxf+1; idxf+2];
        idx2 = idx.^2;
        s = [1/7*idx2-1/5*idx-3/35;
            -1/14*idx2-1/10*idx+12/35;
            -1/7*idx2+17/35;
            -1/14*idx2+1/10*idx+12/35;
            1/7*idx2+1/5*idx-3/35];

    case 'lanczos5' %-- 5-lobe Lanczos interpolation
        Npoints = 6; % 6-point method
        i = repmat(i,Npoints,1);
        j = [idxf-2; idxf-1; idxf; idxf+1; idxf+2; idxf+3];
        s = [sinc(idx+2).*sinc((idx+2)/2);
            sinc(idx+1).*sinc((idx+1)/2);
            sinc(idx).*sinc(idx/2);
            sinc(idx-1).*sinc((idx-1)/2);
            sinc(idx-2).*sinc((idx-2)/2);
            sinc(idx-3).*sinc((idx-3)/2)];
end

clear idx*

if isIQ % phase rotation (if I/Q signals)
    tau = tau(I);
    s = s.*exp(1i*wc*repmat(tau,Npoints,1));
end
clear tau

%-- DAS matrix (M)
M = s; clear s
M = sparse(i,j,M,Nx,nl*nc);
% M is a [numel(x)]-by-[nl*nc] sparse matrix


end



function structArray = IgnoreCaseInFieldNames(structArray)

switch inputname(1)
    case 'param'
        fieldLIST = {'attenuation','baffle','bandwidth','c','elements',...
            'fc','fnumber','fs','f0','image','kerf','Nelements',...
            'passive','pitch','radius','RXangle','RXdelay',...
            'TXapodization','TXdelay','TXfreqsweep','TXnow','t0','width'};
end

OldFieldNames = fieldnames(structArray);
tmp = lower(OldFieldNames);
assert(length(tmp)==length(unique(tmp)),...
    ['The structure ' upper(inputname(1)),...
    ' contains duplicate field names (when ignoring case).'])

[idx,loc] = ismember(lower(fieldLIST),tmp);
idx = find(idx); loc = loc(idx);
for k = 1:length(idx)
    tmp = eval(['structArray.' OldFieldNames{loc(k)}]); %#ok
    structArray = rmfield(structArray,OldFieldNames{loc(k)});
    eval(['structArray.' fieldLIST{idx(k)} ' = tmp;']) %#ok
end

end

function [xV,yV,zV] = vxdcr3(xe,ye,delaysTX,c)
%VXDCR3   3-D virtual transducer (XDCR)
%   [xV,zV,zV] = VXDCR3 returns the positions of the elements of the 3-D
%   virtual transducer.
%
%   The virtual transducer is an "equivalent" transducer assuming null
%   delays.
%
%   -- Damien Garcia -- 2024/06, last update: 2024/06/26
%                                [simplified version]
T2 = delaysTX(:)'.^2;
xe = xe(:)';
ye = ye(:)';
[dT2dx,dT2dy] = trigrad(xe,ye,T2);
xV = xe-c^2*dT2dx/2;
yV = ye-c^2*dT2dy/2;
zV = -sqrt(abs(c^2*T2-(xe-xV).^2-(ye-yV).^2));
end

function [dzdx,dzdy] = trigrad(x,y,z)
%   [dZdX,dZdY] = TRIGRAD(X,Y,Z) returns an approximation to the gradient
%   of Z defined for the scattered data (X,Y).
%
%   dZdX corresponds to the partial derivative dZ/dX, and dZdY corresponds
%   to the partial derivative dZ/dY.
%
%   TRIGRAD uses a first order approximation. Z is assumed to be a
%   piecewise planar function over the triangulated region. The partial
%   derivative of each plane (ax + by + c = z) is a in the x direction and
%   b in the y direction. A given node in the triangulation is associated
%   with several triangles. The partial derivative at each node is the
%   weighted mean of each of the partial derivatives of the triangles
%   associated with that node.
%
%   Adapted from Mick Warehime (Matlab FEX)
%   $Version 2.1$ $Date: 2013/04/05$
%
%   -- Damien Garcia -- 2024/06, last update: 2024/06/26

siz0 = size(x);
assert(isequal(siz0,size(y),size(z)),...
    'X, Y, and Z must be of same size')
x = x(:); y = y(:); z = z(:);

% Delaunay triangulation
tri = delaunay(x,y);

% side lengths of the triangles
s1 = hypot(x(tri(:,2))-x(tri(:,1)),y(tri(:,2))-y(tri(:,1)));
s2 = hypot(x(tri(:,3))-x(tri(:,1)),y(tri(:,3))-y(tri(:,1)));
s3 = hypot(x(tri(:,2))-x(tri(:,3)),y(tri(:,2))-y(tri(:,3)));

% semi-perimeters
s = (s1+s2+s3)/2;

% areas (Heron's formula)
A = sqrt(s.*(s-s1).*(s-s2).*(s-s3));

% "equilaterality" of the triangles (= 2*inradius/circumradius)
% 1 if equilateral, 0 if degenerate
E = 8*A.^2./(s.*s1.*s2.*s3);

% remove degenerate triangles
idx = E>0.25;
tri = tri(idx,:);
E = E(idx);
A = A(idx);

% Face derivatives
tr = triangulation(tri,x,y,z);
F = faceNormal(tr);
dzdx = -F(:,1)./F(:,3);
dzdy = -F(:,2)./F(:,3);

% number of triangles and points
nt = size(tri,1);
np = length(z);

% map matrix from triangles to nodes
M = sparse(repmat((1:nt)',3,1),tri,1,nt,np);

% weighted mean of the partial derivatives (a or b coefficient) using the
% "equilaterality" of each triangle for a given node
dzdx = (M'*(dzdx.*E))./(M'*E);
dzdy = (M'*(dzdy.*E))./(M'*E);

dzdx = reshape(dzdx,siz0);
dzdy = reshape(dzdy,siz0);

end